{
  "Zod Schema": {
    "prefix": "zodschema",
    "body": [
      "export const ${1:name}Schema = z.object({",
      "  $0",
      "});",
      "export type ${1:Name} = z.infer<typeof ${1:name}Schema>;"
    ],
    "description": "Create a Zod schema with TypeScript type"
  },
  "Function Component": {
    "prefix": "fc",
    "body": [
      "type ${1:Component}Props = {",
      "  ${2}",
      "};",
      "",
      "const ${1:Component} = ({ $0 }: ${1:Component}Props) => {",
      "  return null;",
      "};",
      "",
      "export { ${1:Component} };",
      "export type { ${1:Component}Props };"
    ],
    "description": "Create a TypeScript React functional component"
  },
  "Zustand Provider": {
    "prefix": "zustandprovider",
    "body": [
      "export type ${1:Store}State = {};",
      "export type ${1:Store}Action = {};",
      "const initialState: ${1:Store}State = {};",
      "",
      "export const { Provider: ${1:Store}Provider, useStoreProvider: use${1:Store}, useStoreProviderShallow: use${1:Store}Shallow } =",
      "  createZustandStoreProvider<${1:Store}State & ${1:Store}Action>({",
      "    name: '${1:Store}',",
      "    creator: immer((set, get) => ({",
      "      ...initialState",
      "    })",
      "  });",
      "$0"
    ],
    "description": "Create a Zustand store provider"
  },
  "Bottom Sheet Dialog": {
    "prefix": "bottomsheet",
    "body": [
      "const [${1:example}, { show, hide }] = useDialog();",
      "",
      "<${1:Example}Dialog dialog={${1:example}} />",
      "",
      "const ${1:Example}Dialog = (props: DialogProps) => {",
      "  const [dialog, { hide }] = useDialogProps(props);",
      "",
      "  return (",
      "    <Dialog dialog={dialog} bottomSheet>",
      "      <BottomSheetContainer title={'Title'} close={hide}>",
      "        $0",
      "      </BottomSheetContainer>",
      "    </Dialog>",
      "  );",
      "};"
    ],
    "description": "Create a bottom sheet dialog component"
  },
  "Context Provider": {
    "prefix": "provider",
    "body": [
      "export const [use${1:Example}Context, ${1:Example}Provider, ${1:Example}Consumer] = createCtx(() => {",
      "  $0",
      "  return {};",
      "}, '${1:Example}');"
    ],
    "description": "Create a React context provider"
  },
  "Expo Page": {
    "prefix": "expopage",
    "body": [
      "export default function Page() {",
      "  return <Box className={'flex-1'} />;",
      "}"
    ],
    "description": "Create an Expo page component"
  },
  "Next.js Page": {
    "prefix": "nextpage",
    "body": [
      "export const metadata: Metadata = {",
      "  title: '',",
      "};",
      "",
      "type Props = {",
      "  params: Promise<{ id: string }>;",
      "  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;",
      "};",
      "",
      "export async function generateMetadata(",
      "  { params, searchParams }: Props,",
      "  parent: ResolvingMetadata,",
      "): Promise<Metadata> {",
      "  // read route params",
      "  const id = (await params).id;",
      "",
      "  return {",
      "    title: '',",
      "  };",
      "}",
      "",
      "export function generateStaticParams() {",
      "  return [];",
      "}",
      "",
      "export default function Page() {",
      "  return null;",
      "}"
    ],
    "description": "Create a Next.js page with metadata"
  },
  "MMKV Local Storage": {
    "prefix": "mmkv",
    "body": [
      "import { useCallback, useRef, useState } from 'react';",
      "import { MMKV } from 'react-native-mmkv';",
      "import type { StateStorage } from 'zustand/middleware/persist';",
      "",
      "const mmkv = new MMKV();",
      "",
      "type Options<T> = {",
      "  putAndReturnIfAbsent?: T;",
      "  returnIfAbsent?: T;",
      "};",
      "",
      "type DefaultGetFunction<T> = (key: string, options: Options<T>) => T;",
      "",
      "class LocalStorage {",
      "  set = <T extends number | string | boolean>(key: string, value: T) => {",
      "    mmkv.set(key, value);",
      "  };",
      "",
      "  private createWithDefaultFunction = <T extends number | string | boolean>({",
      "    isValidValueChecker,",
      "    getter,",
      "  }: {",
      "    isValidValueChecker: (data?: T) => boolean;",
      "    getter: (key: string) => T | undefined;",
      "  }): DefaultGetFunction<T> => {",
      "    return (key, { putAndReturnIfAbsent, returnIfAbsent }) => {",
      "      if (!isValidValueChecker(putAndReturnIfAbsent) && !isValidValueChecker(returnIfAbsent)) {",
      "        throw new Error('putAndReturnIfAbsent or returnIfAbsent should be not nullable');",
      "      }",
      "",
      "      let ret = getter(key);",
      "      if (isValidValueChecker(ret)) {",
      "        return ret!;",
      "      } else {",
      "        if (isValidValueChecker(putAndReturnIfAbsent)) {",
      "          this.set(key, putAndReturnIfAbsent as any);",
      "          return putAndReturnIfAbsent!;",
      "        } else {",
      "          return returnIfAbsent!;",
      "        }",
      "      }",
      "    };",
      "  };",
      "",
      "  getString = (key: string): string | undefined => mmkv.getString(key);",
      "  getStringWithDefault = this.createWithDefaultFunction<string>({",
      "    isValidValueChecker: (d) => typeof d === 'string',",
      "    getter: this.getString,",
      "  });",
      "",
      "  getNumber = (key: string): number | undefined => mmkv.getNumber(key);",
      "  getNumberWithDefault = this.createWithDefaultFunction<number>({",
      "    isValidValueChecker: (d) => typeof d === 'number',",
      "    getter: this.getNumber,",
      "  });",
      "",
      "  getBoolean = (key: string): boolean | undefined => mmkv.getBoolean(key);",
      "  getBooleanWithDefault = this.createWithDefaultFunction<boolean>({",
      "    isValidValueChecker: (d) => typeof d === 'boolean',",
      "    getter: this.getBoolean,",
      "  });",
      "",
      "  setArray = <T>(key: string, values: T[]) => {",
      "    this.set(key, JSON.stringify(values));",
      "  };",
      "",
      "  getArray = <T>(key: string, defaultValue: T[] = []): T[] => {",
      "    const raw: string | undefined = this.getString(key)?.trim();",
      "    if (raw && raw[0] === '[' && raw[raw.length - 1] === ']') {",
      "      return JSON.parse(raw) as T[];",
      "    } else {",
      "      this.setArray(key, defaultValue);",
      "      return defaultValue;",
      "    }",
      "  };",
      "",
      "  setObject = <T extends object>(key: string, value: T) => {",
      "    this.set(key, JSON.stringify(value));",
      "  };",
      "",
      "  getObject = <T extends object>(key: string, defaultValue?: T): T | undefined => {",
      "    const raw: string | undefined = this.getString(key)?.trim();",
      "    if (raw && raw[0] === '{' && raw[raw.length - 1] === '}') {",
      "      return JSON.parse(raw) as T;",
      "    } else {",
      "      return defaultValue;",
      "    }",
      "  };",
      "",
      "  remove = (key: string) => mmkv.delete(key);",
      "}",
      "",
      "const instance = new LocalStorage();",
      "",
      "export const zustandPersistStorage: StateStorage = {",
      "  setItem: (name: string, value: any) => {",
      "    return instance.set(name, value);",
      "  },",
      "  getItem: (name: string) => {",
      "    const value = instance.getString(name);",
      "    return value ?? null;",
      "  },",
      "  removeItem: (name: string) => {",
      "    return instance.remove(name);",
      "  },",
      "};",
      "",
      "export default instance;",
      "$0"
    ],
    "description": "Create MMKV local storage implementation with React hooks"
  },
  "Create Context": {
    "prefix": "createctx",
    "body": [
      "import React, { ReactNode, createElement, ReactElement } from 'react';",
      "",
      "export type ChildrenTransformer = (children?: ReactNode) => ReactNode | undefined;",
      "",
      "function createCtx<T, P extends object>(",
      "  delegate: (props: P, transformChildren: (transformer: ChildrenTransformer) => void) => T,",
      ") {",
      "  const context = React.createContext<T | undefined>(undefined);",
      "",
      "  const Provider = ({ children: _children, ...props }: { children?: ReactNode } & P): ReactElement => {",
      "    let children = _children;",
      "",
      "    const value = delegate(props as P, (transformer) => {",
      "      children = transformer(children);",
      "    });",
      "",
      "    return createElement(context.Provider, { value }, children);",
      "  };",
      "",
      "  return [",
      "    () => {",
      "      const c = React.useContext(context);",
      "      if (!c) {",
      "        throw new Error('useContext를 특정 Provider 내부에서 사용하지 않았습니다.');",
      "      }",
      "      return c;",
      "    },",
      "    Provider as P extends object ? typeof Provider : React.ComponentType<{ children?: ReactNode }>,",
      "    context.Consumer as React.Consumer<T>,",
      "  ] as const;",
      "}",
      "",
      "export default createCtx;",
      "$0"
    ],
    "description": "Create a context utility function"
  },
  "Zustand Persist Store": {
    "prefix": "zustandpersist",
    "body": [
      "import { create } from 'zustand';",
      "import { persist, createJSONStorage } from 'zustand/middleware';",
      "import { immer } from 'zustand/middleware/immer';",
      "",
      "export type ${1:Name}State = { _hasHydrated: boolean; _markHydrate: () => void; reset: () => void };",
      "",
      "const initialState: OmitFunctions<${1:Name}State> = { _hasHydrated: false };",
      "",
      "export const use${1:Name} = create<${1:Name}State>()(",
      "  persist(",
      "    immer((set, get) => {",
      "      return {",
      "        ...initialState,",
      "        reset: () => set((s) => { return { ...initialState, _hasHydrated: s._hasHydrated } }, true),",
      "        _markHydrate: () => set({ _hasHydrated: true }),",
      "      }",
      "    }),",
      "    {",
      "      version: 0,",
      "      name: '${1:Name}-storage',",
      "      storage: createJSONStorage(() => zustandPersistStorage),",
      "      onRehydrateStorage: (s) => () => s._markHydrate(),",
      "    }",
      "  )",
      ");",
      "",
      "export const use${1:Name}Store = () => use${1:Name}(useShallow((s) => s));",
      "$0"
    ],
    "description": "Create a persisted Zustand store"
  },
  "Zustand Store": {
    "prefix": "zustand",
    "body": [
      "import { create } from 'zustand';",
      "import { immer } from 'zustand/middleware/immer';",
      "",
      "export type ${1:Example}State = { reset: () => void };",
      "",
      "const initialState: OmitFunctions<${1:Example}State> = {};",
      "",
      "export const use${1:Example} = create<${1:Example}State>()(",
      "  immer((set, get) => {",
      "    return {",
      "      ...initialState,",
      "      reset: () => set(initialState),",
      "    }",
      "  })",
      ");",
      "",
      "export const use${1:Example}Store = () => use${1:Example}(useShallow((s) => s));",
      "$0"
    ],
    "description": "Create a basic Zustand store"
  },
  "Zustand Store Provider": {
    "prefix": "zustandstoreprovider",
    "body": [
      "import type { PropsWithChildren } from 'react';",
      "import { createContext, useContext } from 'react';",
      "import { createStore, useStore } from 'zustand';",
      "import { useShallow } from 'zustand/react/shallow';",
      "import { useStoreWithEqualityFn } from 'zustand/traditional';",
      "",
      "export function create${1:Name}StoreProvider<State, InitialStateParam = void>({",
      "  creator,",
      "  name = '${1:Name}',",
      "}: {",
      "  creator: Parameters<ReturnType<typeof createStore<State>>>[0];",
      "  name?: string;",
      "}) {",
      "  const _createStore = (initialState?: InitialStateParam) =>",
      "    createStore<State>()((set, get, store) => ({",
      "      ...creator(set, get, store),",
      "      ...initialState,",
      "    }));",
      "  const Context = createContext<ReturnType<typeof _createStore> | null>(null);",
      "  Context.displayName = name;",
      "",
      "  const Provider = (",
      "    props: PropsWithChildren<",
      "      InitialStateParam extends void",
      "        ? { initialState?: InitialStateParam }",
      "        : { initialState: InitialStateParam }",
      "    >,",
      "  ) => {",
      "    const store = useRefValue(() => _createStore(props.initialState));",
      "    return <Context.Provider value={store}>{props.children}</Context.Provider>;",
      "  };",
      "",
      "  function useStoreProvider(): State;",
      "  function useStoreProvider<T>(selector: (state: State) => T): T;",
      "  function useStoreProvider<T>(",
      "    selector: (state: State) => T,",
      "    equalityFn: (lhs: T, rhs: T) => boolean,",
      "  ): T;",
      "  function useStoreProvider(selector?: any, equalityFn?: any) {",
      "    const store = useContext(Context);",
      "    if (!store) {",
      "      throw new Error(`Missing ${name} Provider in the tree`);",
      "    }",
      "    if (equalityFn) {",
      "      return useStoreWithEqualityFn(store, selector, equalityFn);",
      "    } else if (selector) {",
      "      return useStore(store, selector);",
      "    } else {",
      "      return useStore(store);",
      "    }",
      "  }",
      "",
      "  const useStoreProviderShallow = <T,>(selector: (state: State) => T) => {",
      "    return useStoreProvider(useShallow(selector));",
      "  };",
      "",
      "  return { Provider, useStoreProvider, useStoreProviderShallow, Consumer: Context.Consumer };",
      "}",
      "$0"
    ],
    "description": "Create a Zustand store provider utility"
  }
}
